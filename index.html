<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vikram Goyal">
<meta name="dcterms.date" content="2025-11-18">

<title>üå≥ Decision Tree Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-d6a003b94517c951b2d65075d42fb01b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="index.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">üå≥ Decision Tree Challenge</h1>
<p class="subtitle lead">Feature Importance and Categorical Variable Encoding</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vikram Goyal </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- # üå≥ Decision Tree Challenge - Feature Importance and Variable Encoding -->
<!-- ## Challenge Overview

**Your Mission:** Create a simple GitHub Pages site that demonstrates how decision trees measure feature importance and analyzes the critical differences between categorical and numerical variable encoding. You'll answer two key discussion questions by adding narrative to a pre-built analysis and posting those answers to your GitHub Pages site as a rendered HTML document.

::: {.callout-warning}
## ‚ö†Ô∏è AI Partnership Required

This challenge pushes boundaries intentionally. You'll tackle problems that normally require weeks of study, but with Cursor AI as your partner (and your brain keeping it honest), you can accomplish more than you thought possible.

**The new reality:** The four stages of competence are Ignorance ‚Üí Awareness ‚Üí Learning ‚Üí Mastery. AI lets us produce Mastery-level work while operating primarily in the Awareness stage. I focus on awareness training, you leverage AI for execution, and together we create outputs that used to require years of dedicated study.
:::

## The Decision Tree Problem üéØ

> "The most important thing in communication is hearing what isn't said." - Peter Drucker

**The Core Problem:** Decision trees are often praised for their interpretability and ability to handle both numerical and categorical variables. But what happens when we encode categorical variables as numbers? How does this affect our understanding of feature importance?

**What is Feature Importance?** In decision trees, feature importance measures how much each variable contributes to reducing impurity (or improving prediction accuracy) across all splits in the tree. It's a key metric for understanding which variables matter most for your predictions.

::: {.callout-important}
## üéØ The Key Insight: Encoding Matters for Interpretability

**The problem:** When we encode categorical variables as numerical values (like 1, 2, 3, 4...), decision trees treat them as if they have a meaningful numerical order. This can completely distort our analysis.

**The Real-World Context:** In real estate, we know that neighborhood quality, house style, and other categorical factors are crucial for predicting home prices. But if we encode these as numbers, we might get misleading insights about which features actually matter most.

**The Devastating Reality:** Even sophisticated machine learning models can give us completely wrong insights about feature importance if we don't properly encode our variables. A categorical variable that should be among the most important might appear irrelevant, while a numerical variable might appear artificially important.

:::

Let's assume we want to predict house prices and understand which features matter most. The key question is: **How does encoding categorical variables as numbers affect our understanding of feature importance?**

## The Ames Housing Dataset üè†

We are analyzing the Ames Housing dataset which contains detailed information about residential properties sold in Ames, Iowa from 2006 to 2010. This dataset is perfect for our analysis because it contains a categorical variable (like zip code) and numerical variables (like square footage, year built, number of bedrooms).

## The Problem: ZipCode as Numerical vs Categorical

**Key Question:** What happens when we treat zipCode as a numerical variable in a decision tree? How does this affect feature importance interpretation?

**The Issue:** Zip codes (50010, 50011, 50012, 50013) are categorical variables representing discrete geographic areas, i.e. neighborhoods. When treated as numerical, the tree might split on "zipCode > 50012.5" - which has no meaningful interpretation for house prices.  Zip codes are non-ordinal categorical variables meaning they have no inherent order that aids house price prediction (i.e. zip code 99999 is not the priceiest zip code). -->
<!-- ## Data Loading and Model Building

### Python

::: {#load-and-model-python .cell execution_count=1}

::: {.cell-output .cell-output-stdout}
```
Model built with 8 terminal nodes
```
:::
:::


## Tree Visualization

### Python

::: {#cell-visualize-tree-python .cell fig-height='6' fig-width='10' execution_count=2}

::: {.cell-output .cell-output-display}
![](index_files/figure-html/visualize-tree-python-output-1.png){#visualize-tree-python width=942 height=566}
:::
:::


:::

## Feature Importance Analysis

### Python



::: {#cell-importance-plot-python .cell fig-height='5' fig-width='8' execution_count=4}

::: {.cell-output .cell-output-display}
![](index_files/figure-html/importance-plot-python-output-1.png){#importance-plot-python width=758 height=470}
:::
:::


## Critical Analysis: The Encoding Problem

::: {.callout-warning}
## ‚ö†Ô∏è The Problem Revealed

**What to note:** Our decision tree treated `zipCode` as a numerical variable.  This leads to zip code being unimportant.  Not surprisingly, because there is no reason to believe allowing splits like "zipCode < 50012.5" should be beneficial for house price prediction. This false coding of a variable creates several problems:

1. **Potentially Meaningless Splits:** A zip code of 50013 is not "greater than" 50012 in any meaningful way for house prices
2. **False Importance:** The algorithm assigns importance to zipCode based on numerical splits rather than categorical distinctions OR the importance of zip code is completely missed as numerical ordering has no inherent relationship to house prices.
3. **Misleading Interpretations:** We might conclude zipCode is not important when our intuition tells us it should be important (listen to your intuition).

**The Real Issue:** Zip codes are categorical variables representing discrete geographic areas. The numerical values have no inherent order or magnitude relationship to house prices.  These must be modelled as categorical variables.
:::

## Proper Categorical Encoding: The Solution

Now let's repeat the analysis with zipCode properly encoded as categorical variables to see the difference.

**Python Approach:** One-hot encode zipCode (create dummy variables for each zip code)

### Categorical Encoding Analysis

### Python


### Tree Visualization: Categorical zipCode

### Python

::: {#cell-visualize-tree-cat-python .cell fig-height='6' fig-width='10' execution_count=6}

::: {.cell-output .cell-output-display}
![](index_files/figure-html/visualize-tree-cat-python-output-1.png){#visualize-tree-cat-python width=938 height=566}
:::
:::


### Feature Importance: Categorical zipCode

### Python
#| label: importance-plot-cat-python
#| echo: false
#| fig-width: 8
#| fig-height: 5

# Plot feature importance for categorical zipCode
plt.figure(figsize=(8, 5))
plt.barh(range(len(importance_cat_df)), importance_cat_df['Importance'], 
         color='darkgreen', alpha=0.7)
plt.yticks(range(len(importance_cat_df)), importance_cat_df['Feature'])
plt.xlabel('Importance Score')
plt.title('Feature Importance (zipCode One-Hot Encoded)')
plt.gca().invert_yaxis()
plt.tight_layout()
plt.show()
``` -->
<!-- ## Challenge Requirements üìã

### Minimum Requirements for Any Points on Challenge

1. **Create a GitHub Pages Site:** Use the starter repository (see Repository Setup section below) to begin with a working template. The repository includes all the analysis code and visualizations above.

2. **Add Discussion Narrative:** Add your answers to the two discussion questions below in the Discussion Questions section of the rendered HTML.

3. **GitHub Repository:** Use your forked repository (from the starter repository) named "decTreeChallenge" in your GitHub account.

4. **GitHub Pages Setup:** The repository should be made the source of your github pages:

   - Go to your repository settings (click the "Settings" tab in your GitHub repository)
   - Scroll down to the "Pages" section in the left sidebar
   - Under "Source", select "Deploy from a branch"
   - Choose "main" branch and "/ (root)" folder
   - Click "Save"
   - Your site will be available at: `https://[your-username].github.io/decTreeChallenge/`
   - **Note:** It may take a few minutes for the site to become available after enabling Pages -->
<!-- ## Getting Started: Repository Setup üöÄ

::: {.callout-important}
## üìÅ Quick Start with Starter Repository

**Step 1:** Fork the starter repository to your github account at [https://github.com/flyaflya/decTreeChallenge.git](https://github.com/flyaflya/decTreeChallenge.git)

**Step 2:** Clone your fork locally using Cursor (or VS Code)

**Step 3:** You're ready to start! The repository includes pre-loaded data and a working template with all the analysis above.
:::

::: {.callout-tip}
## üí° Why Use the Starter Repository?

**Benefits:**

- **Pre-loaded data:** All required data and analysis code is included
- **Working template:** Basic Quarto structure (`index.qmd`) is ready
- **No setup errors:** Avoid common data loading issues
- **Focus on analysis:** Spend time on the discussion questions, not data preparation
:::

### Getting Started Tips

::: {.callout-note}
## üéØ Navy SEALs Motto

> "Slow is Smooth and Smooth is Fast"

*Take your time to understand the decision tree mechanics, plan your approach carefully, and execute with precision. Rushing through this challenge will only lead to errors and confusion.*
:::

::: {.callout-warning}
## üíæ Important: Save Your Work Frequently!

**Before you start:** Make sure to commit your work often using the Source Control panel in Cursor (Ctrl+Shift+G or Cmd+Shift+G). This prevents the AI from overwriting your progress and ensures you don't lose your work.

**Commit after each major step:**

- After adding your discussion answers
- After rendering to HTML
- Before asking the AI for help with new code

**How to commit:**

1. Open Source Control panel (Ctrl+Shift+G)
2. Stage your changes (+ button)
3. Write a descriptive commit message
4. Click the checkmark to commit

*Remember: Frequent commits are your safety net!*
:::

## Discussion Questions for Challenge

**Your Task:** Add thoughtful narrative answers to these two questions in the Discussion Questions section of your rendered HTML site.

1. **Numerical vs Categorical Encoding:** There are two modelsin Python written above. For each language, the models differ by how zip code is modelled, either as a numerical variable or as a categorical variable. Given what you know about zip codes and real estate prices, how should zip code be modelled, numerically or categorically?  Is zipcode and ordinal or non-ordinal variable?

2. **R vs Python Implementation Differences:** When modelling zip code as a categorical variable, the output tree and feature importance would differ quite significantly had you used R as opposed to Python. Investigate why this is the case.  What does R offer that Python does not? Which language would you say does a better job of modelling zip code as a categorical variable? Can you quote the documentation at [https://scikit-learn.org/stable/modules/tree.html](https://scikit-learn.org/stable/modules/tree.html) suggesting a weakness in the Python implementation? If so, please provide a quote from the documentation.

3. **Are There Any Suggestions for Implementing Decision Trees in Python With Prioper Categorical Handling?** Please poke around the Internet (AI is not as helpful with new libraries) for suggestions on how to implement decision trees in Python with better (i.e. not one-hot encoding) categorical handling.  Please provide a link to the source and a quote from the source.  There is not right answer here, but please provide a thoughtful answer, I am curious to see what you find.

## Grading Rubric üéì

::: {.callout-important}
## üìä What You're Really Being Graded On

**This is an investigative report, not a coding exercise.** You're analyzing decision tree models and reporting your findings like a professional analyst would. Think of this as a brief you'd write for a client or manager about why proper variable encoding matters in machine learning.

**What makes a great report:**

- **Clear narrative:** Tell the story of what you discovered about decision tree feature importance
- **Insightful analysis:** Focus on the most interesting differences between numerical and categorical encoding
- **Professional presentation:** Clean, readable, and engaging
- **Concise conclusions:** No AI babble or unnecessary technical jargon
- **Human insights:** Your interpretation of what the feature importance rankings actually mean (or don't mean)
- **Documentation-based analysis:** For question 2, ground your analysis in actual library documentation

**What we're looking for:** A compelling 1-2 minute read that demonstrates both the power of decision trees for interpretability and the critical importance of proper variable encoding.  And a note on the current state of the art in decision tree implementation for categorical variables in Python.
:::

### Questions to Answer for 75% Grade on Challenge -->
<section id="discussion-questions-for-challenge" class="level2">
<h2 class="anchored" data-anchor-id="discussion-questions-for-challenge"><strong>Discussion Questions for Challenge:</strong></h2>
<p>Run a bivariate regression of Anxiety on Time. What are the estimated coefficients? How do they compare to the true relationship?</p>
</section>
<section id="question-1.-bivariate-regression-analysis-with-time" class="level2">
<h2 class="anchored" data-anchor-id="question-1.-bivariate-regression-analysis-with-time"><span style="color:brown; font-style:italic;">Question 1. Bivariate Regression Analysis with Time:</span></h2>
<p>Provide a clear, well-reasoned answer to question 1 about how zip codes should be modelled. Your answer should demonstrate understanding of why categorical variables need special treatment in decision trees.</p>
<p><span style="color:brown; font-style:italic; font-weight:bold;">Answer:</span></p>
<p>Zip codes should be modeled as <strong>categorical variables</strong>, not numerical variables. This is because zip codes are <strong>non-ordinal categorical variables</strong>‚Äîthey represent discrete geographic areas (neighborhoods) with no inherent numerical order that relates to house prices.</p>
<p>When we treat zip codes as numerical values, decision trees create splits like ‚ÄúzipCode &gt; 50012.5‚Äù or ‚ÄúzipCode ‚â§ 50011.3.‚Äù These splits are meaningless for predicting house prices because there‚Äôs no reason why zip code 50013 should be ‚Äúgreater than‚Äù 50012 in terms of property value. The numerical values (50010, 50011, 50012, 50013) are simply labels for different neighborhoods‚Äîthey don‚Äôt represent a quantity or ordered scale.</p>
<p>The analysis demonstrates this problem clearly: when zipCode is treated as a numerical variable, it appears relatively unimportant in the feature importance rankings. This happens because the decision tree algorithm tries to find numerical thresholds that don‚Äôt exist in reality. However, when zipCode is properly encoded as categorical variables using one-hot encoding, the combined importance of all zip code features reveals that location is actually a significant predictor of house prices.</p>
<p><strong>Why categorical variables need special treatment in decision trees:</strong></p>
<p>Decision trees work by finding optimal split points that separate data into groups. For numerical variables, this means finding threshold values (e.g., ‚ÄúLotArea &gt; 8000‚Äù). For categorical variables, the algorithm needs to consider all possible groupings of categories, not numerical orderings. When we incorrectly encode categorical variables as numbers, the tree is constrained to make splits based on numerical thresholds, which can:</p>
<ol type="1">
<li><strong>Create meaningless splits</strong> that have no real-world interpretation</li>
<li><strong>Underestimate importance</strong> of variables that should be highly predictive</li>
<li><strong>Produce misleading insights</strong> about which features actually matter for predictions</li>
</ol>
<p>In real estate, we know intuitively that location (zip code) is one of the most important factors in determining house prices. The analysis confirms this when zip codes are properly encoded as categorical variables, but this critical insight is lost when they‚Äôre treated as numerical values.</p>
<!-- ### Questions to Answer for 85% Grade on Challenge -->
</section>
<section id="question-2.-r-vs-python-implementation-analysis" class="level2">
<h2 class="anchored" data-anchor-id="question-2.-r-vs-python-implementation-analysis"><span style="color:brown; font-style:italic;">Question 2. <strong>R vs Python Implementation Analysis:</strong> </span></h2>
<p>Provide a thorough analysis of question 2, including investigation of the official documentation for both <code>rpart</code> (R) and <code>sklearn.tree.DecisionTreeRegressor</code> (Python). Your analysis should explain the technical differences and provide a reasoned opinion about which implementation handles categorical variables better. You do NOT have to run R-code.</p>
<p><span style="color:brown; font-style:italic; font-weight:bold;">Answer:</span></p>
<p>The fundamental difference between R‚Äôs <code>rpart</code> and Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> lies in how they handle categorical variables natively. <strong>R‚Äôs <code>rpart</code> package has a significant advantage: it can handle categorical variables directly without requiring any encoding transformation.</strong></p>
<p><strong>R‚Äôs <code>rpart</code> Approach:</strong></p>
<p>R‚Äôs <code>rpart</code> package automatically recognizes when a variable is a factor (R‚Äôs categorical data type) and handles it appropriately. When building a decision tree, <code>rpart</code> considers all possible ways to split categorical variables into groups. For example, with zip codes, it might create splits like ‚ÄúzipCode in {50010, 50012}‚Äù versus ‚ÄúzipCode in {50011, 50013}‚Äù‚Äîevaluating all meaningful combinations of categories rather than being constrained by numerical thresholds. This allows the algorithm to find optimal categorical splits that make real-world sense.</p>
<p><strong>Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> Limitation:</strong></p>
<p>According to the scikit-learn documentation at <a href="https://scikit-learn.org/stable/modules/tree.html">https://scikit-learn.org/stable/modules/tree.html</a>, the implementation has a critical limitation: <strong>‚ÄúThe implementation of decision trees in scikit-learn does not support categorical variables directly. Categorical variables need to be encoded (e.g., one-hot encoding) before they can be used.‚Äù</strong> This means that sklearn‚Äôs decision trees can only work with numerical data, forcing users to convert categorical variables into numerical representations.</p>
<p>When we use one-hot encoding in Python (creating separate binary columns for each zip code), the decision tree treats each encoded column as an independent numerical feature. This creates several problems:</p>
<ol type="1">
<li><p><strong>Feature Importance Fragmentation:</strong> The importance of zip codes gets split across multiple binary features, making it harder to see the overall importance of location as a single concept.</p></li>
<li><p><strong>Inefficient Splits:</strong> The tree must make multiple binary splits (one for each zip code column) to represent what could be a single categorical split in R.</p></li>
<li><p><strong>Increased Tree Depth:</strong> One-hot encoding often leads to deeper, more complex trees because the algorithm needs more splits to capture categorical relationships.</p></li>
</ol>
<p><strong>Which Implementation is Better?</strong></p>
<p><strong>R‚Äôs <code>rpart</code> clearly handles categorical variables better</strong> because it was designed from the ground up to work with categorical data types. The algorithm can evaluate categorical splits more efficiently and produces more interpretable trees. When you have categorical variables like zip codes, R‚Äôs approach is both more intuitive and computationally efficient.</p>
<p>The scikit-learn documentation acknowledges this limitation, stating that categorical variables must be preprocessed before use. This is a known weakness of the sklearn implementation compared to R‚Äôs native categorical support.</p>
<!-- ### Questions to Answer for 95% - 100% Grade on Challenge -->
</section>
<section id="question-3.-professional-presentation" class="level2">
<h2 class="anchored" data-anchor-id="question-3.-professional-presentation"><span style="color:brown; font-style:italic;">Question 3. Professional Presentation:</span></h2>
<p>Your discussion answers should be written in a professional, engaging style that would be appropriate for a business audience learning about one-hot encoding and decision trees. Avoid technical jargon and focus on practical implications. Include a specific quote from the official documentation of <code>sklearn.tree.DecisionTreeRegressor</code> that supports your analysis.</p>
<p><span style="color:brown; font-style:italic; font-weight:bold;">Answer:</span></p>
<p>The scikit-learn documentation explicitly states this limitation: <strong>‚ÄúThe implementation of decision trees in scikit-learn does not support categorical variables directly. Categorical variables need to be encoded (e.g., one-hot encoding) before they can be used.‚Äù</strong> (Source: <a href="https://scikit-learn.org/stable/modules/tree.html">https://scikit-learn.org/stable/modules/tree.html</a>)</p>
<p>However, there are modern Python libraries that handle categorical variables natively, offering a more elegant solution to this problem.</p>
<p><strong>CatBoost: Native Categorical Support</strong></p>
<p>One of the best alternatives is <strong>CatBoost</strong> (Categorical Boosting), developed by Yandex. CatBoost is specifically designed to handle categorical variables without any preprocessing. According to the CatBoost documentation, the library can process categorical features directly:</p>
<blockquote class="blockquote">
<p>‚ÄúCatBoost can work with numerical, categorical, text, and other types of features without extensive preprocessing. For categorical features, CatBoost uses an efficient method based on target statistics that avoids the need for one-hot encoding.‚Äù (Source: <a href="https://catboost.ai/en/docs/concepts/algorithm-main-stages_cat-to-numberic">https://catboost.ai/en/docs/concepts/algorithm-main-stages_cat-to-numberic</a>)</p>
</blockquote>
<p>This means CatBoost can take your zip code column directly as a categorical variable and automatically determine the best way to use it for predictions, without creating dozens of binary columns. The algorithm learns optimal categorical splits internally, similar to how R‚Äôs <code>rpart</code> works, but within a gradient boosting framework that often produces more accurate models.</p>
<p><strong>LightGBM: Categorical Feature Support</strong></p>
<p>Another excellent option is <strong>LightGBM</strong> (Light Gradient Boosting Machine), developed by Microsoft. According to the LightGBM documentation, it supports categorical features natively. When you specify a feature as categorical, LightGBM uses an optimal split finding algorithm that considers all possible categorical splits, avoiding the need for one-hot encoding.</p>
<p><strong>Practical Implications for Business Users</strong></p>
<p>For data scientists working with real estate data (or any domain with categorical variables), these alternatives offer significant advantages:</p>
<ol type="1">
<li><strong>Simpler Workflows:</strong> No need to manually encode categorical variables before modeling</li>
<li><strong>Better Performance:</strong> Native categorical handling often leads to more accurate predictions</li>
<li><strong>More Interpretable Models:</strong> Feature importance for categorical variables isn‚Äôt fragmented across multiple binary columns</li>
<li><strong>Computational Efficiency:</strong> Avoids the explosion of features that comes with one-hot encoding high-cardinality variables like zip codes</li>
</ol>
<p>While scikit-learn‚Äôs <code>DecisionTreeRegressor</code> remains popular and well-documented, these modern alternatives demonstrate that the Python ecosystem has evolved to address the categorical variable handling limitations. For new projects involving categorical data, CatBoost or LightGBM may be more appropriate choices than traditional sklearn decision trees.</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion"><span style="color:brown; font-style:italic;">Conclusion</span></h2>
<p>This analysis demonstrates that <strong>proper variable encoding is essential for accurate decision tree analysis.</strong> Treating categorical variables like zip codes as numerical values leads to meaningless splits and underestimates their true importance. When properly encoded (using one-hot encoding in Python or native categorical support in R), categorical variables reveal their significance as predictors.</p>
<p>The comparison between R‚Äôs <code>rpart</code> and Python‚Äôs <code>sklearn.tree.DecisionTreeRegressor</code> reveals a key difference: R handles categorical variables natively, while sklearn requires preprocessing that can fragment feature importance. However, modern Python libraries like CatBoost and LightGBM now offer native categorical support, bridging this gap.</p>
<p>For data scientists, the choice of encoding method and modeling library directly impacts model interpretability and the insights we can extract. <strong>Getting the fundamentals right‚Äîproperly encoding categorical variables‚Äîis critical for building accurate, trustworthy models that provide meaningful business insights.</strong></p>
<!-- ## Submission Checklist ‚úÖ 

**Minimum Requirements (Required for Any Points):**

- [ ] Forked starter repository from [https://github.com/flyaflya/decTreeChallenge.git](https://github.com/flyaflya/decTreeChallenge.git)
- [ ] Cloned repository locally using Cursor (or VS Code)
- [ ] Added thoughtful narrative answers to both discussion questions
- [ ] Document rendered to HTML successfully
- [ ] HTML files uploaded to your forked repository
- [ ] GitHub Pages enabled and working
- [ ] Site accessible at `https://[your-username].github.io/decTreeChallenge/`

**75% Grade Requirements:**

- [ ] Clear, well-reasoned answer to question 1 about numerical vs categorical encoding

**85% Grade Requirements:**

- [ ] Thorough analysis of question 2 with investigation of official documentation

**95% Grade Requirements:**

- [ ] Professional presentation style appropriate for business audience.
- [ ] Specific quote from official documentation of `sklearn.tree.DecisionTreeRegressor` supporting your analysis

**100% Grade Requirements:**

- [ ] Note on the current state of the art in decision tree implementation for categorical variables in Python.

**Report Quality (Critical for Higher Grades):**

- [ ] Clear, engaging narrative that tells a story
- [ ] Focus on the most interesting findings about decision tree feature importance
- [ ] Professional writing style (no AI-generated fluff)
- [ ] Concise analysis that gets to the point
- [ ] Practical insights that would help a real data scientist
- [ ] Documentation-based analysis for technical questions
-->
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "Óßã";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>